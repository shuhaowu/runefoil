From d0714af192aec952923a0a5d94948e1bc8008f99 Mon Sep 17 00:00:00 2001
From: Shuhao Wu <shuhao@shuhaowu.com>
Date: Thu, 23 May 2019 20:43:05 -0400
Subject: [PATCH 1/3] Runefoil base patch set

Things done:

- Patched up Runelite HTTP Service to not crawl prices as the runefoil
  component will do it.
---
 .../http/service/item/ItemService.java        | 57 +++++--------------
 1 file changed, 14 insertions(+), 43 deletions(-)

diff --git a/http-service/src/main/java/net/runelite/http/service/item/ItemService.java b/http-service/src/main/java/net/runelite/http/service/item/ItemService.java
index 72a0fe85a..5177dc2e0 100644
--- a/http-service/src/main/java/net/runelite/http/service/item/ItemService.java
+++ b/http-service/src/main/java/net/runelite/http/service/item/ItemService.java
@@ -88,7 +88,6 @@ public class ItemService
 	private final CacheService cacheService;
 
 	private final ConcurrentLinkedQueue<PendingLookup> pendingLookups = new ConcurrentLinkedQueue<PendingLookup>();
-	private int[] tradeableItems;
 	private final Random random = new Random();
 
 	@Autowired
@@ -457,49 +456,21 @@ public class ItemService
 				break;
 			case ITEM:
 				fetchItem(pendingLookup.getItemId());
+				// This is a runefoil patched behaviour because we don't run the minio
+				// cache service and thus the reloadItems function won't run (and is
+				// patched out).
+				//
+				// This means that prices will not updated after runelite starts
+				// (runefoil updates the price information before runelite boot, before
+				// the network is locked down, from runelite's API). Adding this line
+				// ensures that the prices might update (keeping in mind that there
+				// are a lot of levels of caches in Runelite that's not patched out,
+				// meaning that the caching mechanism will likely override any sort of
+				// price updates in the server).
+				//
+				// This is an acceptable tradeoff for the time being.
+				fetchPrice(pendingLookup.getItemId());
 				break;
 		}
 	}
-
-	@Scheduled(fixedDelay = 20_000)
-	public void crawlPrices()
-	{
-		if (tradeableItems == null || tradeableItems.length == 0)
-		{
-			return;
-		}
-
-		int idx = random.nextInt(tradeableItems.length);
-		int id = tradeableItems[idx];
-
-		if (getItem(id) == null)
-		{
-			// This is a new item..
-			log.debug("Fetching new item {}", id);
-			queueItem(id);
-			return;
-		}
-
-		log.debug("Fetching price for {}", id);
-
-		fetchPrice(id);
-	}
-
-	@Scheduled(fixedDelay = 1_8000_000) // 30 minutes
-	public void reloadItems() throws IOException
-	{
-		List<ItemDefinition> items = cacheService.getItems();
-		if (items.isEmpty())
-		{
-			log.warn("Failed to load any items from cache, item price updating will be disabled");
-		}
-
-		tradeableItems = items.stream()
-			.filter(item -> item.isTradeable)
-			.mapToInt(item -> item.id)
-			.toArray();
-
-		log.debug("Loaded {} tradeable items", tradeableItems.length);
-	}
-
 }
-- 
2.24.1

